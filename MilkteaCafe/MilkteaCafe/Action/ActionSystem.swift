import Foundation

/// Specifies which model to use for an Action.
enum ModelType {
    case thinking
    case chat
}

/// Defines a unit of work that can drive LLM generations, run custom code, and fire a post-action hook.
protocol Action {
    /// The full chat messages (history & prompt) to send to the LLM.
    var messages: [Message] { get }
    
    // The new message to add
    var message: Message { get }
    
    var systemPrompt: String { get }

    /// If true, the model's KV cache will be cleared before generation.
    var clearKVCache: Bool { get }

    /// Which underlying LlamaModel to use (thinking vs. chat).
    var modelType: ModelType { get }

    /// Optional code hook to inspect or handle the raw LLM output.
    /// - Parameter response: The full string generated by the LLM.
    /// - Returns: A tuple where:
    ///   • didRun determines if `result` should be used instead of the raw response.
    ///   • result is the payload passed into postAction.
    func runCode(on response: String) -> (didRun: Bool, result: Any)

    /// Called exactly once per Action, after generation and runCode.
    /// - Parameter result: Either the LLM string (didRun=false) or a custom payload (didRun=true).
    func postAction(_ result: Any)
}

/// A type-erased Action allowing runCode and postAction closures
struct AnyAction: Action {
    let messages: [Message]
    let message: Message
    let systemPrompt: String
    let clearKVCache: Bool
    let modelType: ModelType
    let tokenFilter: TokenFilter?
    // New property for streaming UI updates
    let progressHandler: ((String) -> Void)?
    private let runCodeClosure: (String) -> (didRun: Bool, result: Any)
    private let postActionClosure: (Any) -> Void

    init(
        systemPrompt: String,
        messages: [Message],
        message: Message,
        clearKVCache: Bool,
        modelType: ModelType,
        tokenFilter: TokenFilter? = nil,
        // New optional parameter for handling streamed tokens
        progressHandler: ((String) -> Void)? = nil,
        runCode: @escaping (String) -> (didRun: Bool, result: Any),
        postAction: @escaping (Any) -> Void
    ) {
        self.messages = messages
        self.message = message
        self.systemPrompt = systemPrompt
        self.clearKVCache = clearKVCache
        self.modelType = modelType
        self.tokenFilter = tokenFilter
        self.progressHandler = progressHandler
        self.runCodeClosure = runCode
        self.postActionClosure = postAction
    }

    func runCode(on response: String) -> (didRun: Bool, result: Any) {
        runCodeClosure(response)
    }

    func postAction(_ result: Any) {
        DispatchQueue.main.async {
            self.postActionClosure(result)
        }
    }
}
